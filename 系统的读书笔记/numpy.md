[TOC]
# numpy的ndarray：一种多维数据对象
## 创建数组
1. 每个数组都有一个shape，和一个dtype 
2. reshape((3,5))。将数组转化成3*5的数组
```
np.arange(15).reshape((3,5))
```

1. 创建数组 用np.array()函数,还有np.zeros((2,3)),np.ones((3,3)),np.eye(n) 单位矩阵     
2. 嵌套的序列将会转化为多维数组   
3. 可以在创建数组的同时，用dtype指定数据的类型  
```python
import numpy as np 
a=[1,2,3,4,5]
b=np.array(a)
#嵌套的序列
a=np.array([[1,2,3],[2,3,4]])#将会是2*3的数组
#指定类型
b=np.array(a，dtype=np.int32)
#转化类型
b.astype(np.float64)
```


4.  所有元素必须具有相同的类型
## 转化数组类型
1. 用 数组.astype(要转化的序列，如np.int64) 代码[^1x]

```python
import numpy as np 
a=[1,2,3,4,5]
b=np.array(a)
#嵌套的序列
a=np.array([[1,2,3],[2,3,4]])#将会是2*3的数组
#指定类型
b=np.array(a，dtype=np.int32)
#转化类型
b.astype(np.float64)
```
## 数组与标量运算
1.大小相等的数组：对应元素进行运算
2.数组与标量运算：数组的每一个元素都与该标量进行运算
## 基本索引和切片
### 一维度
1. a[:]表示选取a内所有数据
2. a[2:5]=1
### 多维
1. 如果为二维 ，那么 用 a[1][2],或者a[1,2]。如果我们想选择第2行和第3行，那么就是a[[2,3]]或者a[[2,3],]。也就是说，切片时，a[A,B]中A，B本应该都是都是列表形式。

2. 假设a为二维，那么 a[1]表示a的第二行，是一维数组，而不是数字。
3. numpy用方括号[]表示维度 。[]表示一维，[[1,2],[3,4]] ,是二维的。1,2在一个维度上面，3,4在一个维度上面，同理[[[,],[,]],[[,],[,]]]就是三维了。
4. 切片的话，a[1:2,3:] , a[1,:] , a[1,2]
### 布尔索引
1. 通过布尔型索引获取的数据，产生的都是副本，而不是视图
1. 布尔型数组的长度，必须跟被索引的轴的长度一致。
2. 形如 a[names=='bob'] , a[name=='bob',3:]
3. -(符号)，和 ！= 的使用。
```python
#选取除bob以外的数据。
a[name！='bob',3:]，a[-(name=='bob')]
```
4. & 与 |  布尔运算符 的使用
```python
a[(name=='bob') | (name=='will')]
```
5. 通过诸如 == , < ,>等等进行索引
6. python关键字 and , or 再布尔型数组中无效
### 花式索引，一次传入多个数据
1. 如果我们想选择第2行和第3行，那么就是a[[2,3]]或者a[[2,3],]。也就是说，切片时，a[A,B]中A，B本应该都是都是列表形式。只是在只有一个数字时，把[]省略掉了。
2. 可以加上符号（-）
3. 注意：花式索引与切片不一样，它总是将数据==复制==到==新数组==	上面。
``` python
In [3]: arr=np.empty((8,4))

In [4]: for i in range(8):
   ...:     arr[i]=i

In [5]: arr
Out[5]: 
array([[ 0.,  0.,  0.,  0.],
       [ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.],
       [ 4.,  4.,  4.,  4.],
       [ 5.,  5.,  5.,  5.],
       [ 6.,  6.,  6.,  6.],
       [ 7.,  7.,  7.,  7.]])

In [6]: arr[0]
Out[6]: array([ 0.,  0.,  0.,  0.])

In [7]: arr[0,1,2,3]
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
<ipython-input-7-1b0d885f0e3b> in <module>()
----> 1 arr[0,1,2,3]

IndexError: too many indices for array

In [8]: arr[[1,2,3],]
Out[8]: 
array([[ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.]])

In [9]: arr[[1,2,3]]
Out[9]: 
array([[ 1.,  1.,  1.,  1.],
       [ 2.,  2.,  2.,  2.],
       [ 3.,  3.,  3.,  3.]])

In [10]: arr[[-2,-4],]
Out[10]: 
array([[ 6.,  6.,  6.,  6.],
       [ 4.,  4.,  4.,  4.]])

In [12]: arr[[2,4,6],[3,1,2]]
Out[12]: array([ 2.,  4.,  6.])
#######################################################
In [14]: arr=np.arange(32).reshape((8,4))

In [15]: arr
Out[15]: 
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23],
       [24, 25, 26, 27],
       [28, 29, 30, 31]])

In [16]: arr[[1,5,7,2]][:,[0,3,1,2]]
Out[16]: 
array([[ 4,  7,  5,  6],
       [20, 23, 21, 22],
       [28, 31, 29, 30],
       [ 8, 11,  9, 10]])



```

## 矩阵的转置和轴变换 （转置就是轴对称）
1. 转置是重塑的一种特殊的方式，他返回的是原数据的视图，而不是复制
1. 二位数组转置，用.T的方法。即A.T
2. 数组的内积用np.dot(x.T,x)
3. 多维可以考虑   transpose() 函数。不是很懂
4. 当然还可以用swapaxes()  方法. 返回的也是视图，而不是复制。也不是很懂

## 数组复制
 1. 注意：一般情况下切片的复制，都是原始数组的视图而不是副本。对视图进行修改会影响原始数组
 2. 转置和轴对称都是 视图，而不是 副本。
 2. 如果想复制副本，那么用 b=a[1:2].copy()
 3. 通过布尔型索引获取的数据，产生的都是副本，而不是视图



# 用于数组内数据计算（或比较）的函数
1. 一般对数组运用某计算函数，其实是对它所有的元素都运用该函数。不如对数组A用np.sqrt(A),那么其实是对A内所有的元素求根号。
2. 比如二元函数np.maximum（x，y），其实是x,y比较对应元素的最大值
3. np.modf(arr)是可以把arr的整数部分和小数部分分开的。结果就是两个数组。
4. 具体的这类函数可参见《利用python进行数据分析》的99页（不知道是不是109页），或者查看官方文档

# 利用数组进行数据处理
## np.where 将条件逻辑表述为数组运算 
用np.where取代 if else 和for的组合。
使用：np.where(布尔数组，数组A，数组B)
```python
x=np.array([1.1,1.2,1.3,1.4,1.5])
y=np.array([2.1,2.2,2.3,2.4,2.5])
c=np.array([True,False,True,True,False])
# 希望c为True时选x，为False时，选y
# python慢方法
result=[(x if c else y) 
	 for x,y,c in zip(x,y,c)]
#np.where 快方法
result=np.where(c,x,y)
# np.where 其他案例
# 将arr 大于0的变为2，否则不变
result=np.where(arr>0,2,arr)
# 更复杂的用法 条件1和条件2同时成立结果为0，仅条件1成立结果为1，仅条件2成立结果为2，都不成立结果为3
np.where(cond1 & cond2 ,0,
			np.where(cond1,1
			          np.where(cond2,2,3)))
			          
	
```

## 数学和统计方法
sum() mean() 可以用来计算指定的轴 。sum(axis=1)。如果不填，就是所有的数据都要计算。
其他的函数 看书里介绍的104页（还是115页），或者看官方文档


## 用于布尔型数组的方法 sum , any ,all
(arr>0).sum() 可以用来计算正数的个数
数组.any() 返回True或者False. 看数组是否含有True
数组.all() 返回True或者False. 看数组是否都是True

## 排序
1.数组名.sort() 可以指定轴 arr.sort(1) 
2.arr.sort()返回的是数组的已排序副本。

### 计算数组分位数
最简单的方法就是对其进行排序，然后选定特定的位置
eg:
```python

arr=randn(1000)
arr.sort()
arr[int(0.05*len(arr))]
```
## 一些特殊功能的函数 比如计算数组内唯一的元素
见书107页（118页）

# 数组文件的读取，存储 (具体可help)
其实numpy 和pandas 都有 这方面的功能
## np.save() , np.load() , np.savez()
保存文件的后缀为.npy
## 抽取==文本==文件
### np.loadtxt() ,np.genfromtxt()
### 或者pandas 的 read_csv() , read_table() ，还有DataFrame() 这些更实用
## 保存 np.savetxt()

# 线性代数
## 矩阵乘法
用dot()函数 ，可以x.dot(y)，或者np.dot(x,y)
而矩阵 的*运算只是对矩阵对应的元素相乘
## 强大的numpy.linalg 
矩阵的运算啥都可以做
常见的numpy.linalg 函数有
见《利用python 进行数据分析》的表4-7第110页（pdf 121页）
# 随机数生成 numpy.random模块 
比python的random模块快的不是一个量级
 见《利用python 进行数据分析》的表4-8第111页（pdf 122页）


